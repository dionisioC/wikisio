{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is my personal blog where I share what I learn mostly about computer science and software development</p> <p></p>"},{"location":"TODO/","title":"To do list","text":"<p>This is an impossible list of things I want to do or learn. Usually I keep them in small pieces of paper, so I miss lots of them. This is a attempt of Keeping them ordered or, at least, reduce the amount of ued paper.</p> <ul> <li> BBQ app with nest and the blog entry about the process</li> <li> Solve coding problems</li> <li> Read the two bundles that I purchased</li> <li> Revisit the master material and implement it in \u2026 nest? quarkus? micronaut? updated spring version? T, W, F 17:30 - 20?</li> <li> Write about DDD and CQRS</li> <li> Implement the prim algorithm and other algorithms that I learnt at the university</li> <li> Make a finite state machine</li> </ul>"},{"location":"coding/express/rest_api_with_express/","title":"Rest API with express","text":""},{"location":"coding/express/rest_api_with_express/#basics","title":"Basics","text":"<p>In order to get a <code>NodeJs</code> project up and running we will use the <code>npm</code> command. <code>Npm</code> stands for node package manager, so we need node installed. <code>Nvm</code> (node version manager) is recommended to manage the <code>NodeJs</code> versions. We will type in the terminal:</p> <pre><code>npm init\n</code></pre> <p>And it will guide us to create the project. We can put a name to out project and accept the defaults.</p> <p>After the command is complete, we will have a <code>package.json</code> file. Inside that file inside the scrips object, we are going to add the following:</p> <pre><code>\"start\": \"node index.js\"\n</code></pre> <p>So the scripts section of the <code>package.json</code> will look like this:</p> <pre><code>  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",\n    \"start\": \"node index.js\"\n  }\n</code></pre> <p>We are doing this because the default main file is called index.js (you can check it) in the main property of the <code>package.json</code> file.</p> <p>Other thing we have to do is create the <code>index.js</code> file. We can do it with</p> <pre><code>touch index.js\n</code></pre> <p>for example.</p>"},{"location":"coding/express/rest_api_with_express/#express","title":"Express","text":"<p>Now we need <code>express</code>. We will install it with</p> <pre><code>npm install --save express\n</code></pre> <p>A new file <code>package-lock.json</code> will appear containing all the metadata as express has some dependencies.</p> <p>Let think we are making a brain. In order to test that everything is up and running we can add the following to the previously created <code>index.js</code>.</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) =&gt; {\n    res.send('Your thought sir');\n})\n\napp.listen(port, () =&gt; console.log(`Brain running on port ${port}`));\n</code></pre> <p>Now running</p> <pre><code>node index.js\n</code></pre> <p>We will see the message that we have in the <code>console.log</code> statement. If we go to <code>http://localhost:3000/</code> we will see the message that is returned in the get.</p>"},{"location":"coding/express/rest_api_with_express/#middlewares","title":"Middlewares","text":"<p>Express is a simple HTTP server, and it does not come with a lot of features out of the box, so we need to install some middlewares to get more features. One of them is body-parser, which helps us decode the body from an HTTP request. We install it with:</p> <pre><code>npm install --save body-parser\n</code></pre> <p>With this we can advance in the development of the rest API as we can get the body of a post.</p> <p>We are going to use an array as a database, in the future we will use a real database</p> <p>Our array will be this one:</p> <pre><code>let thoughts = [\n    {id: crypto.randomUUID(), content: 'Good thought'},\n    {id: crypto.randomUUID(), content: 'Everything is fine'}]\n</code></pre> <p>We add the id, so we can retrieve them, because when you have bad thoughts they usually come again and again.</p> <p>To generate the id we have to add the following import:</p> <pre><code>const crypto = require('crypto')\n</code></pre> <p>Now, we can return all the thoughts in the get endpoint. Notice that the endpoint now has the <code>thoughts</code> path.</p> <pre><code>app.get('/thoughts', (req, res) =&gt; {\n    res.send(thoughts);\n})\n</code></pre> <p>Before the get, we are going to config the body parser with this two lines:</p> <pre><code>app.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\n</code></pre> <p>When you submit form data with a POST request, that form data can be encoded in many ways. The default type for HTML forms is application/x-www-urlencoded, but you can also submit data as JSON or any other arbitrary format.</p> <p>bodyParser.urlencoded() provides middleware for automatically parsing forms with the content-type application/x-www-urlencoded and storing the result as a dictionary (object) in req.body. The body-parser module also provides middleware for parsing JSON, plain text, or just returning a raw Buffer object for you to deal with as needed.</p> <p>With the extended set to false the values can be an array or string.</p> <pre><code>app.post('/thoughts', (req, res) =&gt; {\n    const thoughtContent = req.body.content;\n    const thought = {id: crypto.randomUUID(), content: thoughtContent}\n    thoughts.push(thought);\n\n    res.status(201).send(thought);\n});\n</code></pre> <p>Sometimes, the thoughts leave our brain, so we will add a new endpoint to delete them:</p> <pre><code>app.delete('/thoughts/:id', (req, res) =&gt; {\n    const id = req.params.id;\n\n    for (const thought of thoughts) {\n        if (thought.id === id) {\n            const index = thoughts.indexOf(thought);\n            thoughts.splice(index, 1);\n            res.json(thought);\n            return;\n        }\n    }\n\n    res.status(404).send('Thought not found');\n\n});\n</code></pre> <p>Other times, we just change our mind, so we update our thoughts. To do that we are going to create an endpoint to update them:</p> <pre><code>app.put('/thoughts/:id', (req, res) =&gt; {\n    const id = req.params.id;\n\n    for (const thought of thoughts) {\n        if (thought.id === id) {\n            const index = thoughts.indexOf(thought);\n            thoughts.splice(index, 1);\n            const updatedThought = {id: id, content: req.body.content}\n            thoughts.push(updatedThought);\n            res.json(updatedThought);\n            return;\n        }\n    }\n\n    res.status(404).send('Thought not found');\n\n});\n</code></pre> <p>This is incomplete, things to improve</p> <p>Put inside a docker Make it modular, not just in one file use nodemon</p>"},{"location":"coding/tooling/podman/","title":"Podman","text":""},{"location":"coding/tooling/podman/#podman","title":"Podman","text":"<p>Since Docker changed its usage policy, lots of developers started to use other solutions. One of them is Podman.</p> <p>Some Arch distributions, EndeavourOS, include Podman. Red Hat backs Podman up, making it one of the most popular alternatives to Docker.</p>"},{"location":"coding/tooling/podman/#images","title":"Images","text":"<p>By default, podman goes to the quay.io registry. So if we do:</p> <pre><code>docker run docker.io/hello-world\n</code></pre> <p>We see we are using podman, and we are going to the quay.io registry:</p> <pre><code>Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.\nResolved \"hello-world\" as an alias (/etc/containers/registries.conf.d/\n00-shortnames.conf)\nTrying to pull quay.io/podman/hello:latest\u2026\nGetting image source signatures\nCopying blob d08b40be6878 done   |\nCopying config e2b3db5d4f done   |\nWriting manifest to image destination\n!\u2026 Hello Podman World \u2026!\n\n         .--\"--.\n       / -     - \\\n      / (O)   (O) \\\n   ~~~| -=(,Y,)=- |\n    .---. /`  \\   |~~\n ~/  o  o \\~~~~.----. ~~\n  | =(X)= |~  / (O (O) \\\n   ~~~~~~~  ~| =(Y_)=-  |\n  ~~~~    ~~~|   U      |~~\n\nProject:   https://github.com/containers/podman\nWebsite:   https://podman.io\nDocuments: https://docs.podman.io\nTwitter:   @Podman_io\n</code></pre> <p>But if we want to use an image that is not available in quay.io, we are going to get the following error:</p> <pre><code>docker run --rm -it -p 4566:4566 -p 4510-4559:4510-4559 localstack/localstack\n</code></pre> <pre><code>Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.\nError: short-name \"localstack/localstack\" did not resolve to an alias and no\nunqualified-search registries are defined in \"/etc/containers/registries.conf\"\n</code></pre> <p>One possible fix is to write the qualified name:</p> <pre><code>docker run docker.io/hello-world\n</code></pre> <p>So we get the Docker Hub image:</p> <pre><code>Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.\nTrying to pull docker.io/library/hello-world:latest\u2026\nGetting image source signatures\nCopying blob c1ec31eb5944 done   |\nCopying config d2c94e258d done   |\nWriting manifest to image destination\n\nHello from Docker\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre> <p>Another solution is to add <code>text unqualified-search-registries = [\"docker.io\"]</code> to the <code>text /etc/containers/registries.conf</code> file.</p> <p>For security reasons, it seems to be better to always qualify the images.</p> <p>Now we can do:</p> <pre><code>docker run --rm -it -p 4566:4566 -p 4510-4559:4510-4559 localstack/localstack\n</code></pre> <p>And get:</p> <pre><code>Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.\nResolving \"localstack/localstack\" using unqualified-search registries\n(/etc/containers/registries.conf) Trying to pull\ndocker.io/localstack/localstack:latest\u2026\n</code></pre> <p>Full information can be found by typing:</p> <pre><code>man 5 containers-registries.conf\n</code></pre>"},{"location":"os/arch/ssh/config_ssh_key_keyring_arch_i3/","title":"Configure ssh keys and Gnome keyring in arch and i3","text":"<p>First know that Gnome keyring is not going to be unlocked if there is an autologin, so the <code>/etc/lightdm/lightdm.conf</code> must have autologin-user commented or deleted</p> <p>Install Gnome keyring and other needed dependencies</p> <pre><code>sudo pacman -S gnome-keyring libsecret seahorse\n</code></pre> <p>Inside the <code>.zshenv</code> file</p> <pre><code>if [ -n \"$DESKTOP_SESSION\" ]; then\n    eval $(gnome-keyring-daemon --start)\n    export SSH_AUTH_SOCK\nfi\n</code></pre> <p>In the <code>~/.ssh/config</code></p> <pre><code>Host *\n    AddKeysToAgent yes\n    IgnoreUnknown UseKeychain\n    UseKeychain yes\n    IdentityFile ~/.ssh/id_ed25519\n</code></pre> <p>Not sure if we have to run <code>seahorse</code> and create a password keyring called <code>Login</code> in order to store the password or it is automatically created when logged and the option of \"Automatically unlock this key whenever I'm logged in\"</p> <p>Not sure if this is needed: <code>ssh-add ~/.ssh/id_ed25519</code></p>"}]}