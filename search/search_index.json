{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is my personal blog where I share what I learn mostly about computer science and software development</p> <p></p>"},{"location":"TODO/","title":"To do list","text":"<p>This is an impossible list of things I want to do or learn. Usually I keep them in small pieces of paper, so I miss lots of them. This is a attempt of Keeping them ordered or, at least, reduce the amount of ued paper.</p> <ul> <li> BBQ app with nest and the blog entry about the process</li> <li> Solve coding problems</li> <li> Read the two bundles that I purchased</li> <li> Revisit the master material and implement it in \u2026 nest? quarkus? micronaut? updated spring version? T, W, F 17:30 - 20?</li> <li> Write about DDD and CQRS</li> <li> Implement the prim algorithm and other algorithms that I learnt at the university</li> <li> Make a finite state machine</li> </ul>"},{"location":"coding/express/rest_api_with_express/","title":"Rest API with express","text":""},{"location":"coding/express/rest_api_with_express/#basics","title":"Basics","text":"<p>In order to get a <code>NodeJs</code> project up and running we will use the <code>npm</code> command. <code>Npm</code> stands for node package manager, so we need node installed. <code>Nvm</code> (node version manager) is recommended to manage the <code>NodeJs</code> versions. We will type in the terminal:</p> <pre><code>npm init\n</code></pre> <p>And it will guide us to create the project. We can put a name to out project and accept the defaults.</p> <p>After the command is complete, we will have a <code>package.json</code> file. Inside that file inside the scrips object, we are going to add the following:</p> <pre><code>\"start\": \"node index.js\"\n</code></pre> <p>So the scripts section of the <code>package.json</code> will look like this:</p> <pre><code>  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",\n    \"start\": \"node index.js\"\n  }\n</code></pre> <p>We are doing this because the default main file is called index.js (you can check it) in the main property of the <code>package.json</code> file.</p> <p>Other thing we have to do is create the <code>index.js</code> file. We can do it with</p> <pre><code>touch index.js\n</code></pre> <p>for example.</p>"},{"location":"coding/express/rest_api_with_express/#express","title":"Express","text":"<p>Now we need <code>express</code>. We will install it with</p> <pre><code>npm install --save express\n</code></pre> <p>A new file <code>package-lock.json</code> will appear containing all the metadata as express has some dependencies.</p> <p>Let think we are making a brain. In order to test that everything is up and running we can add the following to the previously created <code>index.js</code>.</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\napp.get('/', (req, res) =&gt; {\nres.send('Your thought sir');\n})\napp.listen(port, () =&gt; console.log(`Brain running on port ${port}`));\n</code></pre> <p>Now running</p> <pre><code>node index.js\n</code></pre> <p>We will see the message that we have in the <code>console.log</code> statement. If we go to <code>http://localhost:3000/</code> we will see the message that is returned in the get.</p>"},{"location":"coding/express/rest_api_with_express/#middlewares","title":"Middlewares","text":"<p>Express is a simple HTTP server, and it does not come with a lot of features out of the box, so we need to install some middlewares to get more features. One of them is body-parser, which helps us decode the body from an HTTP request. We install it with:</p> <pre><code>npm install --save body-parser\n</code></pre> <p>With this we can advance in the development of the rest API as we can get the body of a post.</p> <p>We are going to use an array as a database, in the future we will use a real database</p> <p>Our array will be this one:</p> <pre><code>let thoughts = [\n{id: crypto.randomUUID(), content: 'Good thought'},\n{id: crypto.randomUUID(), content: 'Everything is fine'}]\n</code></pre> <p>We add the id, so we can retrieve them, because when you have bad thoughts they usually come again and again.</p> <p>To generate the id we have to add the following import:</p> <pre><code>const crypto = require('crypto')\n</code></pre> <p>Now, we can return all the thoughts in the get endpoint. Notice that the endpoint now has the <code>thoughts</code> path.</p> <pre><code>app.get('/thoughts', (req, res) =&gt; {\nres.send(thoughts);\n})\n</code></pre> <p>Before the get, we are going to config the body parser with this two lines:</p> <pre><code>app.use(bodyParser.urlencoded({ extended: false }));\napp.use(bodyParser.json());\n</code></pre> <p>When you submit form data with a POST request, that form data can be encoded in many ways. The default type for HTML forms is application/x-www-urlencoded, but you can also submit data as JSON or any other arbitrary format.</p> <p>bodyParser.urlencoded() provides middleware for automatically parsing forms with the content-type application/x-www-urlencoded and storing the result as a dictionary (object) in req.body. The body-parser module also provides middleware for parsing JSON, plain text, or just returning a raw Buffer object for you to deal with as needed.</p> <p>With the extended set to false the values can be an array or string.</p> <pre><code>app.post('/thoughts', (req, res) =&gt; {\nconst thoughtContent = req.body.content;\nconst thought = {id: crypto.randomUUID(), content: thoughtContent}\nthoughts.push(thought);\nres.status(201).send(thought);\n});\n</code></pre> <p>Sometimes, the thoughts leave our brain, so we will add a new endpoint to delete them:</p> <pre><code>app.delete('/thoughts/:id', (req, res) =&gt; {\nconst id = req.params.id;\nfor (const thought of thoughts) {\nif (thought.id === id) {\nconst index = thoughts.indexOf(thought);\nthoughts.splice(index, 1);\nres.json(thought);\nreturn;\n}\n}\nres.status(404).send('Thought not found');\n});\n</code></pre> <p>Other times, we just change our mind, so we update our thoughts. To do that we are going to create an endpoint to update them:</p> <pre><code>app.put('/thoughts/:id', (req, res) =&gt; {\nconst id = req.params.id;\nfor (const thought of thoughts) {\nif (thought.id === id) {\nconst index = thoughts.indexOf(thought);\nthoughts.splice(index, 1);\nconst updatedThought = {id: id, content: req.body.content}\nthoughts.push(updatedThought);\nres.json(updatedThought);\nreturn;\n}\n}\nres.status(404).send('Thought not found');\n});\n</code></pre> <p>This is incomplete, things to improve</p> <p>Put inside a docker Make it modular, not just in one file use nodemon</p>"},{"location":"os/arch/ssh/config_ssh_key_keyring_arch_i3/","title":"Configure ssh keys and Gnome keyring in arch and i3","text":"<p>First know that Gnome keyring is not going to be unlocked if there is an autologin, so the <code>/etc/lightdm/lightdm.conf</code> must have autologin-user commented or deleted</p> <p>Install Gnome keyring and other needed dependencies</p> <pre><code>sudo pacman -S gnome-keyring libsecret seahorse\n</code></pre> <p>Inside the <code>.zshenv</code> file</p> <pre><code>if [ -n \"$DESKTOP_SESSION\" ]; then\neval $(gnome-keyring-daemon --start)\nexport SSH_AUTH_SOCK\nfi\n</code></pre> <p>In the <code>~/.ssh/config</code></p> <pre><code>Host *\n    AddKeysToAgent yes\n    IgnoreUnknown UseKeychain\n    UseKeychain yes\n    IdentityFile ~/.ssh/id_ed25519\n</code></pre> <p>Not sure if we have to run <code>seahorse</code> and create a password keyring called <code>Login</code> in order to store the password or it is automatically created when logged and the option of \"Automatically unlock this key whenever I'm logged in\"</p> <p>Not sure if this is needed: <code>ssh-add ~/.ssh/id_ed25519</code></p>"}]}